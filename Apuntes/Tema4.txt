-----------------------------------------------------------------------------------------------------------------------------
TEMA 4: Memoria
-----------------------------------------------------------------------------------------------------------------------------
Examen el 8 de Enero.
-----------------------------------------------------------------------------------------------------------------------------
Memoria Virtual: abstraccion que proporciona a los procesos una memoria grande, lineal y privada. Para facilitar la vida a
los programadores. Para dar un espacio de direcciones mas mayor. Permite compartir memoria con otros procesos tambien. El
SO gestiona el intercambio de informacion entre MP fisica y la secundaria en dsico(swap) (area de intercambio en Windows).
Los objetivos son:
Sobresuscripcion: mayor memoria aparente. Para ejecutar procesos que usan mas memoria de la disponible.
Multiprogramacion: ejecucion aislada de procesos (y el kernel). Cada proceso memoria aislada. Pero tabien se puede compartir.
Como las librerias compartidas.
Reubicacion: simplifica el desarrollo software permitiendo que los programas se puedan cargar en cualquier posicion. En EC
cada variable tenia su direccion y habria que ir recompilando con cada cambio, com MV se encarga el SO de eso.
-----------------------------------------------------------------------------------------------------------------------------
Memoria Virtual paginada: modelo mas usado frente a la segmentacion. Se divide la MV en paginas de tamaño determinado (4ks
en Linux). Cada pagina cargada tiene su region espejo (marco de pagina) en MP o en disco o asignacion tardia (no reserva
hasta que se lo piden). Hay varios niveles de indireccion de traducciones como habai con el SF.
La Tabla de Paginas contiene:
(1) Marco de Pagina donde esta la pagina.
(2) Presencia, si esta en MP o no para ir o no a buscarla.
(3) Modificacion, para ver si hay que actualizarla o notificar a otros procesos sobre estas modificaciones.
(4) Proteccion, si es de escritura o de lectura-escritura, o ejecutable (NX significa que no es ejecutable esa pagina).
(5) Acceso, para las politicas de reemplazamiento.
(6) Usuario, nivel de privilegio para ver quien puede acceder a esa pagina (usuario-supervisor).
(7) Cache, si se puede llevar o no, si se activa el modo write-thought para que escriba directamente en MP.
La MMU es la unidad de gestion de Memoria. Coge el registro CR3, hace las indirecciones para sacar las direcciones para
acceder a las direcciones de MP o lanzar errorres si ocurren. Para acelerar las traducciones mas usadas o recientemente
usadas se creo la TLB (televe) (cache de traducciones). Una por CPU, junto a la Cache de Nivel 1.
Entonces lo importante, que hace el SO; se encarga de mantenera las tablas de paginas actualizadas, gestionar las excepciones
asgingando nuevas paginas de memorias (bajo demanda porque son lazys), traer paginas de la memoria secundaria, terminar el
proceso (SIGSEV) o accesos no validos (permisos) a memoria, configurar el MMU para que funione correctamente por ejemplo
cuando se cambia de contexto en un procesos refrescando la TLB y actualizando el MMU y configurar los accesos compartidos a
paginas de memoria. Puede hacer que las traducciones de distintos procesos apunten a la misma pagina como cuando se carga una
lirbreria dinamica que se pone en un pagina compartida. Si una pagina no es compartida es privada.
-----------------------------------------------------------------------------------------------------------------------------
Tamaños de pagina: importante. Porque si son muy grandes puede haber fragmentacion interna = las paginas se quedan con
espacio sin usar. Al disminuir el tamaño puede fastiadiar a las traducciones llenando la TLB haciendola menos eficiente al
tener que cargar o echar paginas. Importante el tamaño tambien para la transferencia a Memoria Secundaria, mas gradne mas
tarda y viceversa.
En Linux: el tamaño por defecto es de 4kB {getconf PAGE_SIZE}, comando que devuelve el tamaño de pagina. Linux tiene un
metodo Huge Pages:
-Transparent Huge Pages: puede combinar paginas de 4kB en paginas de 2mB (que son 512 paginas) si estan continuas. Se puede
configurar con {madvise(2)} para decirle lo que vas a hacer con la memoria del proceso. Contiguas en direcciones fisicas.
-Huge Pages: se puede reservar al arrancar el Sistema una pool de paginas de 2mB o 1gB que las aplicacines pueden solicitar. 
Para bases de datos son interesantes o cuando iniciamos la Maquina Virtual.
-----------------------------------------------------------------------------------------------------------------------------
Mapa de memoria de un proceso. Dividido en segmentos. Las importantes: .text (intrucciones), .rodata (cons1tantes), .data (variables globales static inicializadas), .bss (variables globales static NO inicializadas):
//int numero = 21; // .data
//int resultado; // .bss
//const char *msg = "Hola\n"; // .rodata
//static in factor = 2; // (dentro de main) .data
//while(...){ if(...) } // .text
Segmentos de memoria: son areas de memoria contigua con varias paginas de MV (la estructura en Linux es vm_area_struct, que tiene tipo y permisos). Tipos: respaldadas por fichero (si no tiene son anonimas (no respaldadas por un fichero), heap, stack, memoria dinamica), privadas accesibles por solo el proceso o compartidas y accesibles por otros procesos. El heap crece hacia direcciones altas (del 0 al F) y la pila crece hacia direcciones bajas (del F al 0). En el mapa de memoria del procesos esta mapeado el kernel abajo del todo (abajo hacia arriba, las FFs), no es accesible por el usuario. Esta mappeado en todos los procesos para facilitar la llamada a las funciones del sistema. Despues de que algo pasase, las tablas de paginas de traducciones se separan para dar mas porteccion a los programas que de repente podian ver la TLB, entonces ahora mas seguro tras ese parche pero provoca mas fallos de TLB, cosa pocha pero segura. Esto se puede desactivar.
Si un segmento esta respaldado por un fichero, tiene un puntero que contiene el inodo, dentry y address_space. Ademas los segmentos tienen unas flags, unas operaciones (open(), close(),...)
Hay una tabla en las trasnparencias con como suelen ser los segmentos tipicos (.text es File, RX, SHARED y de tamaño fijo). No voy a copiar todos ni a hacer una tabla en Bloc de Notas.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 1 Hoja 4.
// Nos da un codigo y hay preguntas.
#include <stdio.h>
#include <unistd.h>
int num = 22; // Va a .data
int mul; // Va a .bss

const char *msg = "El resultado es:\n"; // Va a .rodata


int main(void) 
{
    static int factor = 2; // Va a .data


    mul = num * factor; // Va a .text
    printf("%s%i\n", msg, mul); // Va a .text y a .rodata el formato


    sleep(600); // Va a .text. Lo pone a sleep para que podamos ver cosas de este proceso, 10 min para us. Y se le ha acabado


    return 0; // Va a .text
}
// Con {readelf programa} se lee un .elf y con -l se ven los segmentos.
// Te dice donde esta cada segmento con su offset en hexadecimal, el tamaño, los permisos (por ejemplo .txt es de solo
// lectura y ejecutable; .rodata es de solo lectura y no ejecutable). Hay una tabla para rellenar con los datos sacados de
// este comando.
// Podemos ver las cosas que hemos visto de la memoria de un procesos podemos ir al directorio del proceso. Viendo maps para // ver las listas de paginas y map_files. Tambien esta pagemap para ver las traducciones para ver en que marco de MF esta
// pero esta en binario y yo no se tu pero no se leer binario.
// En map_files por columnas: direccion virtual-permisos-offset(desplazamiento desde el principio, raras por seguridad)- // dispositivo(manor-minor?)(por si hubiese que recuperar cosas)-inodo-path(que lo respalda). Si no hay path son anonimas,
// solo estan en memoria, si se pierden se pierden. Se ven las librerias compartidas tambien, eh heap y el stack y se ve que
// el stack crece hacia arriba porque la diferencia de direcciones es grande y lo mismo con el heap.
// En maps, regiones de memoria. Mirando desde maps y metiendonos en este directorio y usando... Se le ha acabado el tiempo, // como no hemso recompilado el programa el offset no ha cambiado pero las paginas virtuales son distintas... {sudo strings // (de la ruta donde sabemos que esta por ejemplo .rodata)} podemos ver "El resultado es:\n" y "%s%i\n" entre otras cosas que // tiene .rodata. Si pones al {strings} el .elf pues te muestra todo y entre todo el batiburrillo y en la posicion a partir
// del offset pues efectivamente te vuelves a encontrar las cosas de .rodata.
-----------------------------------------------------------------------------------------------------------------------------
El comando {ps} muestra la memoria consumida por un proceso...y no me ha dado tiempo a copair mas de esta diapositiva Con {top} en VIRT se ve la memoria virtual y con RES es la memoria reservada que es lo improtante porque en VIRT alomejor aparece un 32gB.
-----------------------------------------------------------------------------------------------------------------------------
Al hacer un [fork()] se copian las paginas de memoria vitual pero inteligentemente con copy-on-write, no se copian a menos que se hayan modificado.
Al hacer execve carga un nuevo ejecutable reemplazando el espacio de direcciones.
Al llamar a brK, mueve la localizacion del program break (¿puntero? al final del bloque de datos) lo que aumenta o disminuye el heap.
Al usar mmap que se crea, destruye, redimensiona segementos de diferentes tipos.
-----------------------------------------------------------------------------------------------------------------------------
MMAP: se le puede pasar un origen pero nosotros lo pondremos a NULL para que el SO busque el hueco libre por el que podamos empezar. Flags: para los permisos de esa zona de memoria. Flags para el tipo de fichero o anonimo. Le podemos pedir paginas mas grandes de las estandar.
MUNMAP: para liberar memoria. No se asegura la sincronizacion de la memoria. Para ello hay que sincronizarla primero con [msync(void, size_t, int)].
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 7 hoja 4.
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>


int main(int argc, char *argv[])
{
	int factor = atoi(argv[1]);
    	int elementos = factor * 1024;

    	printf("Inicializando región de memoria\n");

    	int * ptr = (int *) malloc(elementos * sizeof(int));
    	for (size_t i = 0; i < elementos; i++)
	{
        	ptr[i] = 1;
    	}

    	sleep(600);
    	return 0;
}
// Al trazar las llamadas al con {strace} al llamar al programa, el malloc no hace nada porque es muy poca memoria la que se
// esta pidiendo. El puntero que esta devolviendo no esta al principio del heap porque seguramente la libc tenga algo cargado
// ahi. Puede pedir el numero de direcciones que se reservan para la pila al principio. Restar y ya y dividir entre lo que
// ocupe cada direccion. Malloc con poca memoria te lo coge del heap, si pides mas llama a mmap para mappear memoria para
// darte y devuelve el puntero a esa zona para luego poder liberarla. Malloc siempre deja algo de espacio antes de donde te
// da la memoria y te devuelve el puntero a partir de ahi.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 3 hoja 4.
// Escribe un programa que cree una región de memoria (mmap(2)) con las siguientes características: 
#inlude <sys/mman.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])
{
	void * ptr = mmap (NULL, // Origen.
			1024, // Tamaño.
			PROT_READ | PROT_WRITE, // Permisos de lectura y escritura.
			MAP_PRIVATE | MAP_ANOM, // Flags de que es memoria privada y anonima.
			-1, // Archivo.
			0) // Offset.

	// Comprobacion de que se ha mappeado bien la memoria.
	if(ptr == MAP_FAILED) // Importante comparar con la cte y no con -1 que es lo que devuelve.
	{
		perror("mmap()");
		return 1;
	}

	memset(ptr, 0, 1024);
	printfI("PID: %i, VMA: %p\n", getpid(), ptr());

	sleep(6000);

	return 0;
}
// Aunque le pidas un 1kB te da lo minimo de 4kB porque es el tamaño de una pagina.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 4 hoja 4.
//Re-escribir el ejercicio 11 de la Hoja 3 proyectando el fichero de salida (output.txt) en la memoria virtual:
#inlude <sys/mman.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>


// Recibe la region de memoria y el proceso.
void write_char(void * _ptr, int proc)
{
	char * ptr = (char*) _ptr;
	for(int i = 0; i < 5, ++i)
	{
		ptr[proc * 5] + i = '0' + proc; // Esto te da el caracter ASCII. "Truquito".
	}
}

int main(int argc, char *argv[])
{
	// Preparacion del segmento de memoria. Para ello:
	// (1) Mapa compartido.
	// (2) Abrir fichero para poder mappearlo.
	// (3) Tamaño del fichero adecuado. 5 procesos * 5 escrituras = 25, demosle 30 porque si. (+5 porque el padre
	// escribe tambien).
	// (4) Llamar a mmap del fichero.


	// (1)(2)
	int fd = open("salida.txt",
			O_RDWR | O_TRUNC | O_CREAT, // Flags de permisos, trucar a 0 el tamaño y creacion si no existe.
			0660); // Permisos de lectura y escritura para el usuario y grupo.
	// Habria que comprobar que se ha creado bien.

	// (3)
	ftruncate(fd, 30);
	// Tambien habria que comprobar que se ha hecho bien.

	// (4)
	void * ptr = mmap (NULL, // Origen.
			30, // Tamaño. Podria no ponerse el mismo tamaño del fichero.
			PROT_READ | PROT_WRITE, // Permisos de lectura y escritura.
			MAP_SHARED, // Flags de que es memoria compartida.
			-fd, // Archivo.
			0) // Offset.	

	// Comprobacion de que se ha mappeado bien la memoria.
	if(ptr == MAP_FAILED) // Importante comparar con la cte y no con -1 que es lo que devuelve.
	{
		perror("mmap()");
		return 1;
	}

	// Todo esto se tiene que hacer antes que los forks porque la memoria es compartida y hay que usar el ptr comun.

	write_char(ptr, 0); // Llamada del padre que escribe. Se podria hacer con memset en vez de con otro metodo a parte.

	// Creacion de hijos.
	for(int i = 1; i < 6; ++i) // Empezar en 1 para pasarle el id 1 al hijo 1.
	{
		pid_t pid = fork(); // Todo se copia y se crea con copy_on_write.

		if(pid != 0) // Es el padre.
		{
			continue; // El padre no tiene que hacer nada mas que crear hijos.	
		}
		
		write_char(ptr, i);
		exit(0); // Los hijos no tienen que hacer nada mas que escribir asi que salir con exit.
	}

	// Esperar a los 5 hijos.
	for(int i = 0; i < 5; ++i)
	{
		int status;
		pid_t pid;
		pid = wait(&status);

		print("HIJO: %\n", status);
	}

	// Sincronizacion:
	msync(ptr, 30, MS_SYNC);

	// Liberar memoria.
	munmap(ptr, 30);

	return 0;
}
// Cuando el proceso termina tecnicamente se libera todo pero mejor lo hacemos nosotros por saneamiento.
// Respecto a llamadas al sistema este codigo hace menos (exit). Respecto a escritura en disco respecto a write, es igual.
// Respecto a rendimiento, esto es mejor.
-----------------------------------------------------------------------------------------------------------------------------
CACHE DE PAGINAS: mecanismo para acelerar las lecturas y escrituras de disco.
-----------------------------------------------------------------------------------------------------------------------------
GESTION DE LA MEMORIA PRINCIPAL:
Asignacion de Marcos de Pagina: Sistema encargado de buscar marcos de apginas libres para nuevos segmentos. Algcortimo mas comun el Binary Buddie porque usa potencias de 2 para organizar marcos continuos (2^orden). Cuando no hay un region del orden que le has pedido buscar otros ordenes, si es superior se divide en dos buddies dandote uno de ellos y colocando el otro en la lista de regiones libres en su orden correspondiente tras partirlo. Si pides 2 pags y el orden mas cercano el de 3 (8 pags continuas) las va partiendo hasta que te da una de 2 guardando las otras en los ordenenes correspondientes.
Cuando no hay marcos libres hay que determinar cual debe liberarse mediante politicas de reemplazamiento cuyo objetivo es minimizar los fallos de pagina posibles y eliminando las paginas que no se volveran a usar (la que quitamos se usa muy poco o no se usa entonces perfecto para reemplazarla); hay algunas paginas que no se pueden reeemplazar (politica de retencio) como la del Kernel del SO, o procesos priviliegiados puede hacer [mlock()] para guardar paginas, todo esto por el tiempo (al pinnear paginas en memoria pues se tardaria los mismo siempre) y por seguridad; y ambito, local o global, el local solo puede reemplazarse un marco asignado al proceso que causa el fallo o global que se reemplaza cualquier marco. Algoritmos: FIFO (First In First Out), Reloj (FIFO mas vidas en lista circual) y LRU (Last Recent Used).
-----------------------------------------------------------------------------------------------------------------------------
LINUX:
En Linux se juntan cosas, hay una cola de paginas recientemente usadas con Reloj y otra de inactivas que son las que se priorizan para sacar con politica FIFO. 
Hay paginas mappeadas (cache de paginas (activas e inactivas)) y anonimas. Hay un demonio que se encarga de hacer esto (ksawp en Linux). Hay un parametro swappiness que es la frecuencias en la que vuelvas las paginas anonimas a swap (suele estar en 60, 60% de elegir anonimas al swappear).
Out of Memory (OOM) killer:
Mecanismo del nucleo que se usa cuando no se pueden satisfacer las peticiones de asignacion de memoria (incluso despues de reclamar paginas). Se prioriza terminar procesos malos (badness) que se liberara de la memoria. Heuristica de la politica de maldad: cuanta mas memoria use, cuantos mas hijos, cuanto mas nice (menos prioridad no mas bueno) mas malo es y cuanto mas tiempo lleve el proceso mas ajuste. oom_score para guardar esa puntuacion de [0, 1000], caunta mas puntuacion mas malo y por ende se va ates. oom_score_adj para ajustar la puntuacion anterior como para salvar,se lo puedes dar tu y va entre [-1000, 1000].
-----------------------------------------------------------------------------------------------------------------------------
Podemos hacer {cat /proc/meminfo} para ver la info de la memoria, cuanta memoria total hay, memoria disponible, paginas activas e inactivas anonimas y no anonimas, cache, etc en kBs. {vmstat X} para ver los movimientos de la memoria cada X tiempo. {swapon} para ver las particiones de memoria usadas y no usadas, recomendable por el profesor para poder llevar cosas a disco. {top} tambien tiene estadisticas de la memoria. {htop} mas bonito y "grafiquitos"
-----------------------------------------------------------------------------------------------------------------------------
Ejercicio 6 hoja 4:
Memoria paginada con 512 paginas de MV. = 2^9 paginas => 9 bits.
Direcciones: 512 palabras. = 9 bits para refenrenciar cada palabra (2^9)
MP: 10 marcos. => 4 bits

Direcciones virtuales de 18 bits (9 para el numero de pagina y 9 para las palabras en pag).
Direcciones fisicas de 13 bits (4 para los marcos de MP y los 9 ultimos iguales a las direcciones virtuales).

Forma: 0-512 filas|Marco fisico(4bits)|bitValidez(opresencia)(esta en MP o no)|RWX|Ref(referenciada o no)|modificada
(como minimo deberia tener 4(los marcos)+1(bit de validez) y luego le podemos añadir los que queramos).

0x13FF = 0001 0011 1111 1111
Desplazamiento los 9 ultimos, los 9 primeros la pag virtual

La pagina 9 corresponde al marco fisico 4.
(...)
Puede pasar que no forme parte de la MV => violacion de segmento.
O V=0 => traer swap.
-----------------------------------------------------------------------------------------------------------------------------
Ejercicio 8 hoja 4:
Ocupacion:
CPU: 15% (usuario) 3% (sistema).
SWAP: 92%.
N procesos: 50 (estado SLEEP no interrumpido).
Sacamos las conlusiones de que la CPU no esta haciendo casi nada y que hay muchas paginas en pag (hemos movido muchas pags de MP a swap) => memoria muy ocupada, confirmado porque hay mucho procesos. (Esperando pags de mv hagan swap->mem?)

-Aumentar la Memoria => Impacto positivo porque posibilita que haya mas procesos haciendo swap lo que haria que se pudiese usar mas la CPU.
-Mas programas => Imapacto negativo, mas programas, mas procesos implica que acabarian en el estado de espera y acabariamos peor y con el mismo uso de la CPU.
-Aumentar la swap => impacto nulo/negativo.
-Añadir mas CPU => impacto nulo.
-----------------------------------------------------------------------------------------------------------------------------
Como aclaracion la memoria swap es una particion de memoria secundaria.
-----------------------------------------------------------------------------------------------------------------------------
Ejercicio 9 hoja 4:
1) Excepcion del MMU.
2) la paguna es solo R=1 W=0 (.rodata) =>SIGSEG
3) La pagina COW (Copy On Write)
4) copiar (asignacion) y actualizar TP.
-----------------------------------------------------------------------------------------------------------------------------
Ejercicio 10 hoja 4:
128 * 4 bytes = 2^7 * 2^2 = 512 bytes.

Violacion de segmento tras hacer M[200] siendo M[128] -> Falso.
Ejecucion corrompe los datos de la pila -> Verdadero.
Ejecucion corrompe el semento de codigo de programa -> Falso.
Si bucle hace 4096 para recorrer M habra excepcion -> Verdadero.




















