-----------------------------------------------------------------------------------------------------------------------------
TEMA 5: THREADS
-----------------------------------------------------------------------------------------------------------------------------
RESUMEN:
CONCURRENCIA: permite la comparticion de recursos (CPU) entre procesos o threads. Mecanismos como multiprogramacion (tema 3), programacion multi-thread (tema 5) o programacion asincrona (corrutinas de C++, canales de Golang, async/await de Rust...).
PARALELISMO: uso simultaneo de los recursos del sistema (como los cores de una CPU).
SINCRONIZACION: coordinar la ejecucion de varios procesos o threads, en un mismo sistema con:
-Señales (no se usa mucho),
-Ficheros con cerrojos (en el inodo con [flock])(se usa bastente),
-Mutex y variables de condicion,
-Semaforos (SSYSTEM V IPC, POSIX IPC)(no se usa ya),
-Colas de mensajes,
-Sockets (asignatura de RVR).
y en distintos sistema:
-Sockets TCP/UDP (asigntatura RVR).
COMUNICACION: compartir datos entre varios procesos o threads, en un mismo sistema con:
-Threads (Tema 5),
-Memoria compartida (Tema 4),
-Tuberias con y sin nombre (Tema 1),
-Colas de mensajes
-Basados en ficheros (tema 2)
-UNIX sockets (RVR).
y en distintos sistemas:
-Sockets TCP/UDP (RVR).
-----------------------------------------------------------------------------------------------------------------------------
Proceso: son unidades de ejecucion con un espacion en MV y recursos asociados (tabla de ficheros, gestion de señales, etc).
Thread: son "procesos ligeros" en el contexto de un proceso que comparte algunos recursos (especialemnte el espacio de direcciones) pero mantiene su propio contexto de ejecucion con sus recursos, etc. Comparten: atributos como PID, PPID,...; root y cwd; ficheros abiertos; MV. 
Los programas multi-thread ofrecen menor coste de ceracion (no hace falta realizar toda la gestion que supone crear un nuevo proceso), cambios de contexto mas eficientes (cuesta tiempo pero es mas rapida que el cambio entre procesos), modelo de comparticion sencillo (al compartir MV se puede acceder mas facilmente) y son un buen mecanismo para aprovechar el paralelismo y la existencia de varios cores en un mismo procesador. Sin embargo, hay que usar sincronizacion para que otdo esto vaya bien, tienen que usar versiones thread_safe o reentrantes (_r) de las funciones de libreria, dificil desarrollo y depuracion (interbloqueos, condiciones de carrera, etc) y la programacion asincrona es mas eficiente para aplicaciones intesivas en E/S (concurrencia). 
Los procesos y threads son representados por el mismo objeto del kernel (task_struct), se crean con la misma llamada a [clone()(2)] simplemente especificando las cosas que se comparten, los threads tienen un id (TID) que coincide con el PID de task_struct y tienen el mismo Thread Group ID (TGID) (el primer thread es el lider de grupo y ese es el id que se queda como grupo tambien y es heredado a medida que se vayan creando mas threads). Thread principal TID = PID. TGID es el identificador mostrado por {ps} como PID. Usaremos la API POSIX Threads que define un conjunto de interfaces de programacion para aplicaciones multi-thread.
Se crean con [
ptrehad_create(pthread_t(sacado de [pthread_self()(3), tipo opaco que no tendremos que manejar ni usar)*thread, const pthread_attr_t *attr, typeof(void*(void*))*start, void*arg)
]. El thread termina cuando acabe la funcion start, se llame a pthread_exit, sea cancelado por pthread_cancel()(3)(no usar, sincronizar mejor) o el proceso termina. Por defecto los threads se crean como PHREAD_CREATE_JOINABLE como se hacia con los procesos al hacer el [wait()] con [pthread_koin(pthread_t thread, void **retval)], tambien pueden ser PHREAD_CREATE_DETACHED.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 1 hoja 5:
#include <stduio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>


typedef struct _thread_info_t
{
	int num; // ID nuestro.
	phread_t id; // ID de POSIX.
} thread_info_t;

void* haz_thread(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info // Casting para poder utilizarlo.
	printf("Thread %i, sleeping...\n", info->id);
	sleep(info->num);
	return;
}

int main(int argc, char *argv[])
{
	int nThreads = atoi(argv[1]); // Cogemos el numero de threads que queremos de los atributos de entrada.

	thread_info_t *pool = (thread_info_t*) malloc (nThreads * sizeof(thread_info_t)); // Para definir un array dinamico.
	
	// Crear los threads y guardar su informacion.
	for(int i = 0; i < nThread; ++i)
	{
		pool[i].num = i;
	
		pthread_create(&pool[i].id, 0, haz_thread, (void*) &poll[i]);
		//pthread_create(&pool[i].id, NULL, haz_thread, (void*) &poll[i]); // Igual que lo anterior.
	}
	
	// Sincronizar los threads.
	for(int i = 0; i < nThread; ++i)
	{
		//pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\nj", pool[i].num);

	}

	free(pool); // Liberar memoria.

	return 0;
}
// Con {ps -aL} podemos ver los threads que hemos creado. LWP = TID. Se puede hacer {ps -aL -o PID, TIP, TGID,CMD} y te // muestra eso.
// Solo hay una entrada en /proc.
-----------------------------------------------------------------------------------------------------------------------------
REGION CRITICA:
Invariante: son condiciones sobre un estado compartido que tienen todos los threads y que siempre se tiene cumplir cuando se observa fuera de la region critica.
Region critica: area de cogigo dodne se modifica o se consulta el estado compartido del programa, conservan el invariante permitiendo la ejecucion exclusiva de un thread. Recomendable que sean lo mas pequeñas posible para conservar el paralelismo.
Predicados: expresion logicas sobre un invariante para poder o no ejecutar un thread.
En POSIX se declaran con mutex (MUTual EXclusion). Tienen dos estados (lock y unlocked). Solo puede ejecutar el codigo el thread que lo ha bloqueado. Si varios threads quieren entrar a una region critica ya bloqueda, cuando esta se desbloquea nada te asegura cual de ellos entra primero (lo elige el SO y punto). La espera puede ser por tiempo o por try-lock, te puedes ir de la espera para evitar quedarte bloqueado.
[pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;]
-----------------------------------------------------------------------------------------------------------------------------
Work Crew: los threads cooperan mediante la ejecucion independiente de tareas, la tarea por cada thread puede ser diferente. Requieren la sincronizacion en los datos de entrada y salida de las tareas. Calculo de fisicas o Web Servers.
//Ejercicio 2 hoja 5:
#include <stduio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>


typedef struct _thread_info_t
{
	int num; // ID nuestro.
	phread_t id; // ID de POSIX.
} thread_info_t;

typedef struct _suma_p_t
{
	pthread_mutex_t mutex;
	int suma;
} suma_p_t;

void* haz_thread(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info // Casting para poder utilizarlo.

	int suma_parcial = 0;
	int ini = info->tb * info->sum;
	int fin = info->tb * (info->num + 1);

	printf("Thread %i, sumando...%i - %i\n", info->num, ini, fin);
	
	for(int i = ini; i < fin; ++i)
	{
		suma_parcial += i;
	}

	pthread_mutex_ock(&suma.mutex); // Bloqueamos el mutex.

	suma.suma = suma.suma+suma.suma_parcial; 	// Asi se haria sin mutex que tendria un problema de sincronizacion.  							// Porque nada te asegura que sea atomico.
	pthread_mutex_unlock(&suma.mutex); // Desbloqueamos el mutex.

	return;
}

suma_p_t suma = { PTHREAD_MUTEX_INITIALIZER, 0 }; // Lo creamos como global.

int main(int argc, char *argv[])
{
	int nThreads = atoi(argv[1]); // Cogemos el numero de threads que queremos de los atributos de entrada.
	int tBlque = atoi(argv[2]);

	thread_info_t *pool = (thread_info_t*) malloc (nThreads * sizeof(thread_info_t)); // Para definir un array dinamico.
	
	// Crear los threads y guardar su informacion.
	for(int i = 0; i < nThread; ++i)
	{
		pool[i].num = i;
		pool[i].tb = tBloque;
	
		pthread_create(&pool[i].id, 0, haz_thread, (void*) &poll[i]);
	}
	
	// Sincronizar los threads.
	for(int i = 0; i < nThread; ++i)
	{
		//pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\nj", pool[i].num);

	}
	printf("Suma total: %i\nj", suma.suma);

	free(pool); // Liberar memoria.

	return 0;
} // Seguramente este incompleto.
// Alomejor hay que enlazar al hacer gcc haciendo {gcc -o x y -lpthread}
-----------------------------------------------------------------------------------------------------------------------------


























