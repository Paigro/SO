-----------------------------------------------------------------------------------------------------------------------------
TEMA 5: THREADS
-----------------------------------------------------------------------------------------------------------------------------
RESUMEN:
CONCURRENCIA: permite la comparticion de recursos (CPU) entre procesos o threads. Mecanismos como multiprogramacion (tema 3), programacion multi-thread (tema 5) o programacion asincrona (corrutinas de C++, canales de Golang, async/await de Rust...).
PARALELISMO: uso simultaneo de los recursos del sistema (como los cores de una CPU).
SINCRONIZACION: coordinar la ejecucion de varios procesos o threads, en un mismo sistema con:
-Señales (no se usa mucho),
-Ficheros con cerrojos (en el inodo con [flock])(se usa bastente),
-Mutex y variables de condicion,
-Semaforos (SSYSTEM V IPC, POSIX IPC)(no se usa ya),
-Colas de mensajes,
-Sockets (asignatura de RVR).
y en distintos sistema:
-Sockets TCP/UDP (asigntatura RVR).
COMUNICACION: compartir datos entre varios procesos o threads, en un mismo sistema con:
-Threads (Tema 5),
-Memoria compartida (Tema 4),
-Tuberias con y sin nombre (Tema 1),
-Colas de mensajes
-Basados en ficheros (tema 2)
-UNIX sockets (RVR).
y en distintos sistemas:
-Sockets TCP/UDP (RVR).
-----------------------------------------------------------------------------------------------------------------------------
Proceso: son unidades de ejecucion con un espacion en MV y recursos asociados (tabla de ficheros, gestion de señales, etc).
Thread: son "procesos ligeros" en el contexto de un proceso que comparte algunos recursos (especialemnte el espacio de direcciones) pero mantiene su propio contexto de ejecucion con sus recursos, etc. Comparten: atributos como PID, PPID,...; root y cwd; ficheros abiertos; MV. 
Los programas multi-thread ofrecen menor coste de ceracion (no hace falta realizar toda la gestion que supone crear un nuevo proceso), cambios de contexto mas eficientes (cuesta tiempo pero es mas rapida que el cambio entre procesos), modelo de comparticion sencillo (al compartir MV se puede acceder mas facilmente) y son un buen mecanismo para aprovechar el paralelismo y la existencia de varios cores en un mismo procesador. Sin embargo, hay que usar sincronizacion para que otdo esto vaya bien, tienen que usar versiones thread_safe o reentrantes (_r) de las funciones de libreria, dificil desarrollo y depuracion (interbloqueos, condiciones de carrera, etc) y la programacion asincrona es mas eficiente para aplicaciones intesivas en E/S (concurrencia). 
Los procesos y threads son representados por el mismo objeto del kernel (task_struct), se crean con la misma llamada a [clone()(2)] simplemente especificando las cosas que se comparten, los threads tienen un id (TID) que coincide con el PID de task_struct y tienen el mismo Thread Group ID (TGID) (el primer thread es el lider de grupo y ese es el id que se queda como grupo tambien y es heredado a medida que se vayan creando mas threads). Thread principal TID = PID. TGID es el identificador mostrado por {ps} como PID. Usaremos la API POSIX Threads que define un conjunto de interfaces de programacion para aplicaciones multi-thread.
Se crean con [
ptrehad_create(pthread_t(sacado de [pthread_self()(3), tipo opaco que no tendremos que manejar ni usar)*thread, const pthread_attr_t *attr, typeof(void*(void*))*start, void*arg)
]. El thread termina cuando acabe la funcion start, se llame a pthread_exit, sea cancelado por pthread_cancel()(3)(no usar, sincronizar mejor) o el proceso termina. Por defecto los threads se crean como PHREAD_CREATE_JOINABLE como se hacia con los procesos al hacer el [wait()] con [pthread_koin(pthread_t thread, void **retval)], tambien pueden ser PHREAD_CREATE_DETACHED.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 1 hoja 5:
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>


typedef struct _thread_info_t
{
	int num; // ID nuestro.
	pthread_t id; // ID de POSIX.
} thread_info_t;

void* haz_thread(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info; // Casting para poder utilizarlo.
    printf("Thread %i, sleeping...\n", info->num);
	sleep(info->num * 1000);
	return NULL; 
}

int main(int argc, char *argv[])
{
	int nThreads = atoi(argv[1]); // Cogemos el numero de threads que queremos de los atributos de entrada.

	thread_info_t *pool = (thread_info_t*) malloc (nThreads * sizeof(thread_info_t)); // Para definir un array dinamico.
	
	// Crear los threads y guardar su informacion.
	for(int i = 0; i < nThreads; ++i)
	{
		pool[i].num = i;

		pthread_create(&pool[i].id, 0, haz_thread, (void*) &pool[i]);
		//pthread_create(&pool[i].id, NULL, haz_thread, (void*) &pool[i]); // Igual que lo anterior.
	}
	
	// Sincronizar los threads.
	for(int i = 0; i < nThreads; ++i)
	{
		pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\n", pool[i].num);

	}

	free(pool); // Liberar memoria.

	return 0;
}
// Con {ps -aL} podemos ver los threads que hemos creado. LWP = TID. Se puede hacer {ps -aL -o PID, TIP, TGID,CMD} y te // muestra eso.
// Solo hay una entrada en /proc.
-----------------------------------------------------------------------------------------------------------------------------
REGION CRITICA:
Invariante: son condiciones sobre un estado compartido que tienen todos los threads y que siempre se tiene cumplir cuando se observa fuera de la region critica.
Region critica: area de cogigo dodne se modifica o se consulta el estado compartido del programa, conservan el invariante permitiendo la ejecucion exclusiva de un thread. Recomendable que sean lo mas pequeñas posible para conservar el paralelismo.
Predicados: expresion logicas sobre un invariante para poder o no ejecutar un thread.
En POSIX se declaran con mutex (MUTual EXclusion). Tienen dos estados (lock y unlocked). Solo puede ejecutar el codigo el thread que lo ha bloqueado. Si varios threads quieren entrar a una region critica ya bloqueda, cuando esta se desbloquea nada te asegura cual de ellos entra primero (lo elige el SO y punto). La espera puede ser por tiempo o por try-lock, te puedes ir de la espera para evitar quedarte bloqueado.
[pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;]
-----------------------------------------------------------------------------------------------------------------------------
// Work Crew: los threads cooperan mediante la ejecucion independiente de tareas, la tarea por cada thread puede ser // diferente. Requieren la sincronizacion en los datos de entrada y salida de las tareas. Calculo de fisicas o Web Servers.
//Ejercicio 2 hoja 5:
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>


typedef struct _thread_info_t
{
	int num; // ID nuestro.
	phread_t id; // ID de POSIX.
} thread_info_t;

typedef struct _suma_p_t
{
	pthread_mutex_t mutex; // Mutex para proteger el valor.
	int suma;
} suma_p_t;

suma_p_t suma = { PTHREAD_MUTEX_INITIALIZER, 0 }; // Lo creamos como global.

void* haz_thread(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info // Casting para poder utilizarlo.

	int suma_parcial = 0;
	int ini = info->tb * info->sum;
	int fin = info->tb * (info->num + 1);

	printf("Thread %i, sumando...%i - %i\n", info->num, ini, fin);
	
	for(int i = ini; i < fin; ++i)
	{
		suma_parcial += i;
	}

	pthread_mutex_ock(&suma.mutex); // Bloqueamos el mutex.

	suma.suma = suma.suma+suma.suma_parcial; 	// Asi se haria sin mutex que tendria un problema de sincronizacion.  							// Porque nada te asegura que sea atomico.
	pthread_mutex_unlock(&suma.mutex); // Desbloquear el mutex.

	return;
}

int main(int argc, char *argv[])
{
	int nThreads = atoi(argv[1]); // Cogemos el numero de threads que queremos de los atributos de entrada.
	int tBlque = atoi(argv[2]);

	thread_info_t *pool = (thread_info_t*) malloc (nThreads * sizeof(thread_info_t)); // Para definir un array dinamico.
	
	// Crear los threads y guardar su informacion.
	for(int i = 0; i < nThread; ++i)
	{
		pool[i].num = i;
		pool[i].tb = tBloque;
	
		pthread_create(&pool[i].id, 0, haz_thread, (void*) &poll[i]);
	}
	
	// Sincronizar los threads.
	for(int i = 0; i < nThread; ++i)
	{
		//pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\nj", pool[i].num);

	}
	printf("Suma total: %i\nj", suma.suma);

	free(pool); // Liberar memoria.

	return 0;
} // Seguramente este incompleto.
// Alomejor hay que enlazar al hacer gcc haciendo {gcc -o x y -lpthread}
-----------------------------------------------------------------------------------------------------------------------------
Patron lector-escritor: para recursos compartidos que tienen lecturas mas frecuentes. Se permite varias lecturas concurrentes. Tienen prioridad las lecturas (en Linux al menos).
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 6 hoja 5.
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>


typedef struct _thread_info_t
{
	int num; // ID nuestro.
	phread_t id; // ID de POSIX.
} thread_info_t;

typedef struct _shared_int_t
{
	pthread_rwlock_t mutex; // Mutex para proteger el valor.
	int valor;
} shared_int_t;

shared_int_t numero = { PTHREAD_RW_LOCK_INITIALIZER, 0 }; // Lo creamos como global.

#define NUM_LECTURAS = 5;
#define NUM_ESCRITURAS = 3;

void* lector(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info // Casting para poder utilizarlo.

	for(int i = 0; i < NUM_LECTURAS; ++i)
	{
		pthread_rwlock_rdlock(&numero.mutex); // Entramos a la region critica lockeandola.
		printf("L[%i] %i\n", info->num, numero.valor); // Lo que nos pide el ejercicio que hagamos.	
		usleep(100000); // En microsegundos.
		pthread_rwlock_unlock(&numero.mutex); // Desbloquear el mutex.
	}

	return;
}

void* escritor(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info // Casting para poder utilizarlo.

	for(int i = 0; i < NUM_ESCRITURAS; ++i)
	{
		pthread_rwlock_wrlock(&numero.mutex); // Entramos a la region critica lockeandola.
		// Lo que nos pide el ejercicio que hagamos:
		numero.valor++;
		printf("E[%i] %i\n", info->num, numero.valor);	
		usleep(250000); // En microsegundos.
		pthread_rwlock_unlock(&numero.mutex); // Desbloquear el mutex.
	}

	return;
}

int main(int argc, char *argv[])
{
	int lectores = atoi(argv[1]);
	int escritores = atoi(argv[2]);

	thread_info_t *pool= (thread_info_t*)  malloc((lectores + escritores) * sizeof(thread_info_t)); 
	
	for(int i = 0; i < escritores; ++i)
	{
		pool[i].num = 0;
		pthread_create(&(pool[i].id, NULL, escritor, (void*) &pool[i]);
	}

	for(int i = escritores; i < (escritores + lectores); ++i)
	{
		pool[i].num = i - escritores;
		pthread_create(&(pool[i].id, NULL, lector, (void*) &pool[i]);
	}

	// Sincronizar los threads.
	for(int i = 0; i < (escritores + lectores); ++i)
	{
		pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\nj", pool[i].num);
	}

	free(pool); // Liberar memoria.
	return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
VARIABLES DE CONDICION: abstraccion para bloquear y depertetar threads segun la evaluacion de un predicado sobre variables compartidas. Cuando se hace esto se juntan 3 cosas: estado compartido, un mutex y un preidcado a evaluar (uno o varios sobre un mismo estado compartido).
Patron productor-consumidor: conjunto de threads productores de datos y otro conjunto de consumidores que los recogen y los procesan. Dos subpatrones, contando los numeros totales de elementos producidos y consumidos; y pildora envenenada.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 4 hoja 5
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>


#define BUFFER_SIZE 10
#define NUM_ELEMENTOS_A_PRODUCIR 5

typedef struct _thread_info_t
{
	int num; // ID nuestro.
	pthread_t id; // ID de POSIX.
} thread_info_t;

typedef struct _buffer_t
{
	pthread_mutex_t mutex;

	// Variables de condicion, tantas como predicados haya.
	pthread_cond_t produce; // Si se puede producir o no. (elements < buffer_size).
	pthread_cond_t consume; // Si se puede consumir o no. (elements > 0).

	int data[BUFFER_SIZE];

	int in;
	int out;

	int nElements;
} buffer_t;

typedef struct _shared_int_t
{
	pthread_rwlock_t mutex; // Mutex para proteger el valor.
	int valor;
} shared_int_t;

buffer_t buffer = { PTHREAD_MUTEX_INITIALIZER, // Mutex.
			PTHREAD_COND_INITIALIZER, // Produce.
			PTHREAD_COND_INITIALIZER, // Consume.
			0, // In.
			0, // Out.
			0 }; // nElements.

void* productor(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info; // Casting para poder utilizarlo.

	for(int i = 0; i < NUM_ELEMENTOS_A_PRODUCIR; ++i)
	{
		pthread_mutex_lock(&buffer.mutex); // Entrar a la region critica.
		while(buffer.nElements == BUFFER_SIZE) // Normalmente para esperar se pone la condicion negada.
		{
			pthread_cond_wait(&buffer.produce, &buffer.mutex); // Esperar.
		}
		// Modificacion del buffer.
		int item = 100 * info->num + i;
		buffer.data[buffer.in] = item;
		buffer.in = (buffer.in + 1) % BUFFER_SIZE; // Buffer circular.

		buffer.nElements++;

		printf("P[%i] E: %i I: %i in: %i out: %i\n",
			info->num, buffer.nElements, item, buffer.in, buffer.out);

		pthread_cond_signal(&buffer.consume); // Depertar al siguiente en consume.
		pthread_mutex_unlock(&buffer.mutex); // Desbloquear el mutex.

		sleep(1); // Esperar para que no intente ir otra vez a por el mutex inmediatamente.
	}
	return NULL;
}

void* consumidor(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info; // Casting para poder utilizarlo.

	while(1)
	{
		pthread_mutex_lock(&buffer.mutex); // Entrar a la region critica.
		while(buffer.nElements == 0) // Al reves y suponiendo que no pueden ser < 0.
		{
			pthread_cond_wait(&buffer.consume, &buffer.mutex); // Esperar.
		}
		int item = buffer.data[buffer.out];
		buffer.out = (buffer.out + 1) % BUFFER_SIZE; // Buffer circular.

		buffer.nElements--;

		printf("C[%i] E: %i I: %i in: %i out: %i\n",
			info->num, buffer.nElements, item, buffer.in, buffer.out);

		pthread_cond_signal(&buffer.produce); // Despertamos al siguiente que produce.
		pthread_mutex_unlock(&buffer.mutex); // Desbloquear el mutex.
		
	}
	return NULL;
}

int main(int argc, char *argv[])
{
	int productores = atoi(argv[1]);
	int consumidores = atoi(argv[2]);

	thread_info_t *pool = (thread_info_t*)  malloc((productores + consumidores) * sizeof(thread_info_t)); 
	
	for(int i = 0; i < productores; ++i)
	{
		pool[i].num = 0;
		pthread_create(&pool[i].id, NULL, productor, (void*) &pool[i]);
	}

	for(int i = productores; i < (productores + consumidores); ++i)
	{
		pool[i].num = i - productores;
		pthread_create(&pool[i].id, NULL, consumidor, (void*) &pool[i]);
	}

	// Sincronizar los threads.
	for(int i = 0; i < (productores + consumidores); ++i)
	{
		pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\nj", pool[i].num);
	}

	free(pool); // Liberar memoria.
	return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 4 hoja 5 con PILDORA.
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>


#define BUFFER_SIZE 10
#define NUM_ELEMENTOS_A_PRODUCIR 5

typedef struct _thread_info_t
{
	int num; // ID nuestro.
	pthread_t id; // ID de POSIX.
} thread_info_t;

typedef struct _buffer_t
{
	pthread_mutex_t mutex;

	// Variables de condicion, tantas como predicados haya.
	pthread_cond_t produce; // Si se puede producir o no. (elements < buffer_size).
	pthread_cond_t consume; // Si se puede consumir o no. (elements > 0).

	int data[BUFFER_SIZE];

	int in;
	int out;

	int nElements;
} buffer_t;

typedef struct _shared_int_t
{
	pthread_rwlock_t mutex; // Mutex para proteger el valor.
	int valor;
} shared_int_t;

buffer_t buffer = { PTHREAD_MUTEX_INITIALIZER, // Mutex.
			PTHREAD_COND_INITIALIZER, // Produce.
			PTHREAD_COND_INITIALIZER, // Consume.
			0, // In.
			0, // Out.
			0 }; // nElements.

void* productor(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info; // Casting para poder utilizarlo.

	for(int i = 0; i < NUM_ELEMENTOS_A_PRODUCIR; ++i)
	{
		pthread_mutex_lock(&buffer.mutex); // Entrar a la region critica.
		while(buffer.nElements == BUFFER_SIZE) // Normalmente para esperar se pone la condicion negada.
		{
			pthread_cond_wait(&buffer.produce, &buffer.mutex); // Esperar.
		}
		// Modificacion del buffer.
		int item = 100 * info->num + i;
		buffer.data[buffer.in] = item;
		buffer.in = (buffer.in + 1) % BUFFER_SIZE; // Buffer circular.

		buffer.nElements++;

		printf("P[%i] E: %i I: %i in: %i out: %i\n",
			info->num, buffer.nElements, item, buffer.in, buffer.out);

		pthread_cond_signal(&buffer.consume); // Depertar al siguiente en consume.
		pthread_mutex_unlock(&buffer.mutex);  // Desbloquear el mutex.

		sleep(1); // Esperar para que no intente ir otra vez a por el mutex inmediatamente.
	}
	return NULL;
}

void* consumidor(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info; // Casting para poder utilizarlo.

	while(1)
	{
		pthread_mutex_lock(&buffer.mutex); // Entrar a la region critica.
		while(buffer.nElements == 0) // Al reves y suponiendo que no pueden ser < 0.
		{
			pthread_cond_wait(&buffer.consume, &buffer.mutex); // Esperar.
		}
		int item = buffer.data[buffer.out];
		buffer.out = (buffer.out + 1) % BUFFER_SIZE; // Buffer circular.

		buffer.nElements--;

		printf("C[%i] E: %i I: %i in: %i out: %i\n",
			info->num, buffer.nElements, item, buffer.in, buffer.out);

		pthread_cond_signal(&buffer.produce); // Despertamos al siguiente que produce.
		pthread_mutex_unlock(&buffer.mutex); // Desbloqueamos el mutex.

		if(item == -1) // Pildora envenada para acabar la consumicion. Valor a elegir.
		{
			break;
		}

		sleep(2); // Esperar para que no intente ir otra vez a por el mutex inmediatamente.
	}
	return NULL;
}

int main(int argc, char *argv[])
{
	int productores = atoi(argv[1]);
	int consumidores = atoi(argv[2]);

	thread_info_t *pool = (thread_info_t*)  malloc((productores + consumidores) * sizeof(thread_info_t)); 

	// Creacion de producotres.	
	for(int i = 0; i < productores; ++i)
	{
		pool[i].num = 0;
		pthread_create(&pool[i].id, NULL, productor, (void*) &pool[i]);
	}

	// Creacion de consumidores.
	for(int i = productores; i < (productores + consumidores); ++i)
	{
		pool[i].num = i - productores;
		pthread_create(&pool[i].id, NULL, consumidor, (void*) &pool[i]);
	}

	// Escribir pildoras. Una por consumidor. Lo hace el thread principal.
	// Consumidores.
	for(int i = 0; i < consumidores; ++i)
	{
		while(buffer.nElements == BUFFER_SIZE) // Normalmente para esperar se pone la condicion negada.
		{
			pthread_cond_wait(&buffer.produce, &buffer.mutex); // Esperar.
		}
		buffer.data[buffer.in] = -1; // Meter pildora.
		buffer.in = (buffer.in + 1) % BUFFER_SIZE; // Buffer circular.

		buffer.nElements++;

		pthread_cond_signal(&buffer.consume); // Depertar al siguiente en consume.
		pthread_mutex_unlock(&buffer.mutex); // Desbloquear el mutex. ???
	}

	// Sincronizar los threads.
	for(int i = 0; i < (productores + consumidores); ++i)
	{
		pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\nj", pool[i].num);
	}

	free(pool); // Liberar memoria.
	return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 8 hoja 5.
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <direct.h>
#include <sys/stat.h>


#define BUFFER_SIZE 5;

typedef struct _thread_info_t
{
	int num; // ID nuestro.
	pthread_t id; // ID de POSIX.
} thread_info_t;

typedef struct _buffer_t
{
	pthread_mutex_t mutex; // Mutex.

	// Variables de condicion, tantas como predicados haya.
	pthread_cond_t produce; // Si se puede producir o no. (elements < buffer_size).
	pthread_cond_t consume; // Si se puede consumir o no. (elements > 0).

	char data[BUFFER_SIZE][PATH_MAX]; // Este buffer es como el anterior pero con punteros a paths. PATH_MAX lo da el 						// sistema.

	int in;
	int out;

	int nElements;
} buffer_t;

typedef struct _suma_coop_t
{
	pthread_mutex_t mutex;
	unsigned long long total; // A lo loco para qye no se desborde la variable.
} suma_coop_t;


suma_coop_t suma = { PTHREAD_MUTEX_INITIALIZER, // Mutex.
			0 }; // Total.
buffer_t buffer = { PTHREAD_MUTEX_INITIALIZER, // Mutex.
			PTHREAD_COND_INITIALIZER, // Produce.
			PTHREAD_COND_INITIALIZER, // Consume.
			0, // In.
			0, // Out.
			0 }; // nElements.


void * escribeBuffer(char t, int id, const char* item)
{
	pthread_mutex_lock(&buffer.mutex); // Entrar a la region critica.
	while(buffer.nElements == BUFFER_SIZE) // Normalmente para esperar se pone la condicion negada.
	{
		pthread_cond_wait(&buffer.produce, &buffer.mutex); // Esperar.		
	}

	// Modificacion del buffer.
	str,cpy(buffer.data[buffer.in], item);
	buffer.in = (buffer.in + 1) % BUFFER_SIZE; // Buffer circular.

	buffer.nElements++;

	printf("%c[%i] E: %s I: %i in: %i out: %i\n",
		t, id, buffer.nElements, item, buffer.in, buffer.out);

	pthread_cond_signal(&buffer.consume); // Depertar al siguiente en consume.
	pthread_mutex_unlock(&buffer.mutex);  // Desbloquear el mutex.

	sleep(2); // Esperar para que no intente ir otra vez a por el mutex inmediatamente.
	
	return NULL;
}

// Para "/home/user/.bashrc" => path = "/home/user/" y dent => ".bashrc".
void* productor(void *_path)
{ 
	char * path = (char*) _path;// Casting para poder utilizarlo de void a char.

	char item[PATH_MAX];

	DIR * dir = opendir(path);

	struct dirent * dent;
	while((dent = readdir(dir)) != NULL) // Lee las entradas, la guarda y sigue en el bucle hasta que sea NULL.
	{
		sprintf(item, "%s/%s",
				path, dentd_name);

		escribe_buffer('P', 0, item); // Por enunciado solo hay un porductor.
	}
	return NULL;
}

void* consumidor(void *_info)
{
	thread_info_t *info = (thread_info_t*) _info; // Casting para poder utilizarlo.

	char item[PATH_MAX];
	struct stat statbuf;

	while(1)
	{
		pthread_mutex_lock(&buffer.mutex); // Entrar a la region critica.
		while(buffer.nElements == 0) // Al reves y suponiendo que no pueden ser < 0.
		{
			pthread_cond_wait(&buffer.consume, &buffer.mutex); // Esperar.
		}

		strcpy(item, buffer.data[buffer.out]); // Nos guardamos el elemento que toca en item. Hay que copiarla.
		buffer.out = (buffer.out + 1) % BUFFER_SIZE; // Buffer circular.

		buffer.nElements--;

		pthread_cond_signal(&buffer.produce); // Despertamos al siguiente que produce.
		pthread_mutex_unlock(&buffer.mutex); // Desbloqueamos el mutex.

		if(item == '/0') // Pildora envenada para acabar la consumicion. Valor a elegir. Cadena vacia.
		{
			break;
		}
		
		stat(item, &statbuf); 
		
		if(S_IS_REG(statbuf.st_mode)) // Es true si es fichero regular.
		{
			printf("C%[i]: %s - %i\n",
					info->num, item, statbuf.st_size);
			pthread_mutex_lock(&suma.mutex); // Bloquear el mutex.
			suma += statbuf.st_size; // Sumamos el tamaño del fichero.
			pthread_mutex_unlock(&suma.mutex); // Debloquear el mutex.
		}
	}
	return NULL;
}

int main(int argc, char *argv[])
{
	int consumidores = atoi(argv[2]);

	thread_info_t *pool = (thread_info_t*)  malloc(consumidores * sizeof(thread_info_t)); 
	
	// Creacion de el productor.
	pthread_t productor_id;
	pthread_create(&productor_id, NULL, productor, (void*) argv[1]);

	// Creacion de consumidores.
	for(int i = 0; i < consumidores; ++i)
	{
		pool[i].num = i + 1;
		pthread_create(&(pool[i].id), NULL, consumidor, (void*) &pool[i]);
	}

	pthread_join(productor_id, NULL);
	printf("Productor acabado");

	Escribir pildoras.
	for(int i = 0; i < consumidores  a c)
	{	
		escribe_buffer('M', 0, "");
	}

	// Sincronizar los threads consumidores.
	for(int i = 0; i < consumidores; ++i)
	{
		pthread_join(pool[i].id, NULL); // NULL porque no esperamos nada de retorno.
		printf("Thread %i termino\nj", pool[i].num);
	}

	printf("Tamaño total: %lli\n", suma.total);

	free(pool); // Liberar memoria.
	return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
VISIBILIDAD DE LA MEMORIA.
El compilador y hardware reordena el codigo manteniendo la causalidad del programa.
Se pueden hacer barreras de memoria para hacer que se imponga un orden parcial aparente de las operaciones de la barrerra. Pueden ser barreras de lectura, escritura y general/completa (las l/e/g antes de la barrera se completan antes de las operaciones de l/e/g despues de la barrera). En C++11 el ATOMIC que nos dijo Pepa en CON.
La creacion de threads de POSIX, el bloqueo y desbloqueo de mutex, la union de threads y las variables de condicion son barreras. Hay mas pero estan son las que hemos visto en clase. Hay soporte de procesador para barreras en x86 (mfence, sfence, lfence) y ARM (dmb, dsb, usb6).
Hay intrucciones atomicas.
Linux y Windows implementan el futex (fast user space mutex) que son representados por una variable compartida por procesos. La variable se modifica siempre mediante operaciones atomicas. Las operaciones sin contienda (sin esperas?) se hacen en el espacio de usuario.
-----------------------------------------------------------------------------------------------------------------------------
HASTA AQUI ENTRA EN EL EXAMEN.
-----------------------------------------------------------------------------------------------------------------------------