-----------------------------------------------------------------------------------------------------------------------------
TEMA 2: SISTEMA DE FICHEROS.
-----------------------------------------------------------------------------------------------------------------------------
LEYENDA:
Bloque de terminal o codigo en C: //Terminal:.
Codigo en C: [malloc()].
Comandos en terminal: {ls -a}.
Variables de terminal o de C: 'fd'.
-----------------------------------------------------------------------------------------------------------------------------
FICHEROS:
Se componen de el inodo que es con sus bloques de datos.
Para sacar el inodo con: {stat x} o {ls -i}.
-----------------------------------------------------------------------------------------------------------------------------
//Terminal:
stat miid // Info del i-nodo y demas.
ls -l /dev/ | grep 254 // En donde del disco esta???
// Podemos sacar el 254 (que es el dispositivo donde esta) hacemos:
ls -l /dev/ | grep $(stat miiid.c | Device | cut -d ':' 2 | cut -d ',' -f1) 
// Se corta tanto porque "stat miid.c | Device" 
// escribe "Device: 254,2 Inode: xxx, Links: 1" y nos queremos quedar solo con el 254.
// Se puede preguntar en el examen, si mezcla Tema1 con Tema2.
ls -a // Te enseña todos los ficheros, los ocultos tambien.
-----------------------------------------------------------------------------------------------------------------------------
PERMISOS:
Cadena de 10 caracteres. El primero indica si es archivo(-) o directorio (d), fichero de bloques (b),
fichero de caracteres (c) o para Enlaces (l).
El resto, de 3 en 3, son los permisos para el Usuario (u), Grupo(g) y Otros Ususarios (o).
Los permisos son de lectura(r), escritura (w), ejecucion (x) y ninguno (-).
Para cambiar permisos con:
{chmod o + x}, le da a otros el permiso de ejcucion. Si no se especifica 'ugo' se lo hace a todos. Para concatenar 
con comas {chmod u+rw, g-x, o=rwx}.
Para manera octal: 1 reprenta 'x', 2 reprenseta 'w' y 4 representa 'r'.
La suma de estos valores sirve para ejecutar {chmod} ({chmod 741} da todos al 'u', 'w' a 'g' y 'x' a 'o').
A usuario se refiere al propietario del fichero y al grupo propietario.
Los permisos de ejcucion para directorios permiten o no hacer cd al directorio.
Borrar un fichero de un directorio depende de los permisos del directorio, no del fichero.
-----------------------------------------------------------------------------------------------------------------------------
Delante de la cadena de permisos hay otros bits de permisos especiales (3): setuid, setguid y sticky.
Cuando los dos primeros estan activos cuando se crean un fihcero obtiene el ususario y grupo no del proceso sino
del padre.
Si estan activos aparecera como '-rws--s--t'.
El sticky activo (con t en vez de x en o) se usa para proteger ficheros para que solo puedan ser borrados por el propieterio
del fichero en directorios que tienen todos los permisos para todo el mundo.
-----------------------------------------------------------------------------------------------------------------------------
Para cambiar de propietario un fichero se usa chown.
{sudo chown root:root otro.txt}, se necesitan permisos de superusuario para ejecutarlo por seguridad.
Con sudo se ejecuta el comando como root.
Si un proceso crea un fichero obtiene es propietario del proceso que lo ejecuta.
{sudo chmod +s archivo.txt}
-----------------------------------------------------------------------------------------------------------------------------
DIRECTORIOS:
Arbol de directorios. Contiene una tabla de nombres de ficheros que contiene con sus inodos.
El '.' se refiere al directorio actual. El '..' se refiere al directorio padre. Estas dos entradas siempre estan en la tabla.
Si no estan esta en un lugar especial y magico que luego dira.
Para sacar el inodo de '.' o '..' se usa {ls -id ..}, el 'd' es para que no interprete el '..' como directorio al que se
le esta pidiendo lo que hay dentro sino para que diga su inodo.
{debugfs } // Muestra info del sistema de ficheros.
La organizacion del Sistema de Ficheros varia.
Cuando borramos un fichero se deja el fichero sin enlaces o todos menos el que acabamos de quitar.
-----------------------------------------------------------------------------------------------------------------------------
ENLACES:
Se puede usar {unlink ruta/fichero} para quitarle un enlace. Si llega a 0 se elimina.
Recuerdo de que los inodos tienen un campo 'Numero de Enlances'.
Enlace duro: mismo fichero con distintos enlaces de entrada.
Solo se pueden hacer en el propio Sistema de Ficheros. Porque para acceder al mismo inodo tienen que estar en el mismo SF.
Por ejemplo teniendo dos directorios como /home/usuario/ y /usr/share. Tenemos un data.txt en el primero con inodo 1496
y lo mismo en el segundo directorio.
Lo voy a dibujar en el cuaderno (SO 26-9-2025).
Enlace simbolico: fichero que apunta a un inodo de tipo especial (enlace simbolico) y la informacion que contiene es el path
al fichero al que apunta (que tendra otro inodo). Si la ruta no existe (si haces un enlace simbolico a un USB y lo sacas,
la ruta queda invalida) y se denomina Enlace Roto.
La ruta puede ser relativa o absoluta. Hay que tener cuidado de cual usar por si se mueve ese fichero porque se pueden romper
enlaces. Mejor absolutas pues.
Su tamaño es el tamaño de la ruta ("./prueba" ocupa 8).
Los directorios tienen minimo 2 enlaces, el que apunta desde el padre y el que apunta desde si mismo (el '.'). A eso se le
suman los directorios hijos que tenga.
-----------------------------------------------------------------------------------------------------------------------------
//Terminal: para crear enlaces.
ln // Para crear enlaces. Se añade -s para enlace simbolico.
ln prueba duro // Crea un enlace que se llama duro.
ln -s ./prueba unenlace // Crea un enlace simbolico llamado unenlace con la ruta relativa puesta.
// Tras esto solo habra 2 ficheros: el fichero al que apuntan prueba y duro y el fichero unenlace.
-----------------------------------------------------------------------------------------------------------------------------
//Terminal: mostrar cosas y como se concatenanan comandos.
file $(ls -a) // Muestra los tipos de archivo que le da ls -a.
-----------------------------------------------------------------------------------------------------------------------------
//Terminal:
dd ficheroEntrada ficheroSlida bs=x // Para copia binaria de un archivo a otro de x en x.
dd if=/dev/urandom of=./rand bs=52 bc=4
-----------------------------------------------------------------------------------------------------------------------------
//Terminal: ejercicio 4 hoja 2, hacer stat.

// FALTA.

-----------------------------------------------------------------------------------------------------------------------------

FALTA teoria sobre permisos de ficheros.

-----------------------------------------------------------------------------------------------------------------------------
//Terminal: ejercicio 8 hoja 2.
#include <fcntl.h>
#include <unistd.h>
#include <studio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
	int in_fd, out_fd;
	in_fd = open(argv[1]), O_RDONLY);
	if(in_fd == -1)
	{	
		perror("Open() in");
		return 1;
	}

	out_fd = open(argv[2]), O_WRONLY | O_CREAT | O_TRUNC, 0444);	// Permisos: que solo se pueda escribir, que se cree 
									// si no existe y que trunque. 
									// Tiene que empezar en 0 el octal.
	if(out_fd == -1)
	{	
		perror("Open() out");		
		return 1;
	}

	int blockSize = argv[3]; // Hay que comprobar que no sea mayor al tamaño del buffer.
	int count = argv[4];

	char buffer[8192]; 	// Como un char es un bite creamos un array de char para hacer un buffer de bites.
				// Para direccionar bites.

	int total_bytes = 0;

	// Falta que se haga para el numero de bloques que se ha introducido.
	while(total_bytes < blockSize)
	{
		int rc += read(in_fd, buffer + total_bytes, blockSize - total_bytes) 
		// Desciptor desde el que leer. Buffer donde queremos escribir. Tamaño de los bites que queremos leer.

		// Resultados tras leer.
		if(rc == 0)
		{
			break;
		}

		total_bytes +=rc;
	}

	// Falta la escritura.

	close(in_fd);
	close(out_fd);
}
-----------------------------------------------------------------------------------------------------------------------------
Para abrir un directorio usamos [opendir(name)] que devuelve un puntero.
Para leer las entradas [readdir(dir)] que devuelve un struct con las entradas siendo el path desde donde se ejecuta.
Y para cerrar [closedir(dir)].
-----------------------------------------------------------------------------------------------------------------------------
//Terminal: ejercicio de hacer el 'ls' nosotros.
int main(int argc, char *argv[])
{
	DIR* dir = opendir(argv[1]);

	struct* entries;

	while((entries;= readdir(dir)) != NULL)
	{
		char path[8192]; // El numero en el enunciado no es aleatorio como este.
		//printf("---> %s\n", dent->d_name);
		snprintf(path, 8192, "%s/%s", argv[1], entries->d_name); // Para concatenar y que ponga la ruta completa.
	}
}
// Creo que esto se puede tiene que meter en el ejercicio de stat.
-----------------------------------------------------------------------------------------------------------------------------
SISTEMA DE FICHEROS (FS):
Sistema para organizar ficheros y directorios en una estructura. Con una interfaz. Oparaciones para interacturar con el y
sus elementos. Hay un punto de montaje del arbol del sistema de ficheros.
SISTEMA DE FICHEROS VIRTUAL (VFS):
Conjunto de estructuras de datos que tiene el nucleo del SO para soportar diferentes SFs con interfaz conmuun y abstrae
las cosas especificas de cada uno.
*Superbloques:
Bloque de control que guarda la informacion del Sistema de ficheros de esa particion para organizar. Guarda el tipo de SF,
tamaño de cada bloque, tamaño maximo de fichero, su estado, las listas de control de acceso, ...
Sin el superbloque el SF se pierda. Hay copias de seguridad en otros bloques del disco porque es bastante importante. El
numero de copias depende del SF.
Con {stat -f _path_} nos da la info del SF.Con {df -T} muetra todos los SFs montados en la maquina y muestra propiedades
parecidad al comando anterior.
*Ficheros:
Estructura distinta al inodo. Representa a un fichero abierto por un proceso. Cuando se abre un fichero con open
Contiene metodos para poder escribir, ver, leer, ... El fichero tiene un enlace a una entrada del directorio, para poder
acceder al inodo. Tiene punteros a funciones para poder hacer los metodos anteriormente dichos.
(El inodo tiene una referencia al superbloque al que esta asociado)
(Cuando hacemos en C [read(fd)] tras obtener el 'fd' de un [open], ese 'fd' vale 3 lo que apunta a un tipo FILE)
*Gestion de bloques:
-Asignacion de bloques: le vamos a intentar pedir que mantenga estas cosas.
--Localidad Espacial: quermemos los datos de un fichero juntos para tener un buen rendimineto. Para discos mecanimos para
evitar mover la cabeza de mas. En los SSD para tener que calcular menos operaciones.
--Fragmentacion:
---Externa aunque vayas asignando la memoria bien los movimientos, asignaciones o desasignaciones de memoria hacen
que se creen huecos entre medias. Se pueden hacer programas para ir reordenando los huecos. (Le pediremos baja fragmentacion
externa).
---Interna: el espacio que no se utiliza tras asignar espacio menor al tamaño de bloque. (Dificil de solucionar).
---Mitigar la fragmentacion. Algunos SFs aplican todas o parte.
----Extends: en vez de dar bloques individuales, se da un grupo de bloques dando un bloque inicial y un numero de bloques
tras el. Te aseguras que todos los bloques de un exteds esten seguidos. Pero pedir 2 extends no te asegura que los 2 esten
seguidos. En ext4 no puede haber extends de mas de 128MB como dato.
----Asignacion retardada: los bloques se asignan cuando los datos se escriben en disco, asi calculas bien donde y cuanto
ocupa en bloques.
----Preasignacion de bloque: cuando pides memoria se preasignan bloques. Cuando se cierra el archivo se liberan los no
usados. Con [fallocate(x)] se piden x bloques contiguos.
----Agrupacion de bloques.
-Estructura SF ext4:
|Superbloque|Descriptores de grupo|Mapa de bloques|Mapa de inodos|tabla de inodos|Bloques de datos|
-Estrategias de asignacion:
--Asignacion contigua: se van asignando bloques contiguos. Se suele usar solo para medios de solo lectura.
--FATx: 2^x bloques. Los bloques se almacenan como una lista enlacada. Quien dice lista dice tabla. En la tabla estan todos los numeros de
bloque y el estado del bloque que puede tener BAD (algo esta mal), FREE (bloque libre) y el numero del bloque siguiente en
la lista (EOF si es fin de archivo). Para sistemas pequeños como USBs puede venir bien. Te libras de la fragmentacion
externa.
--Bloques indexados: el inodo guarda punteros directos a bloque=Indices directos.
Tambien hay punteros indirectos que llevan a bloques con punteros a bloques. Hay hasta triples indirecciones.
Se reduce la fragmentacion externa. Si los ficheros son pequeños el acceso es muy eficiente. Cuanto mas grande el fichero mas
cuesta acceder o borrar. Ejemplos: ext2 y UFS (Unix File System).
Tamaño maximo en cuaderno 9-10-2025 SO.
-----------------------------------------------------------------------------------------------------------------------------
Arboles balnceados. Datos solo en hojas. Raices+intermedias calves ("bloques"). Tamaño reducido (5-4 niveles).
-----------------------------------------------------------------------------------------------------------------------------
Ficheros dispersos (sparse):
Ficheros parcialmente vacios con regiones sin datos. EL SF no los lee.
-----------------------------------------------------------------------------------------------------------------------------
Ejercicio 10 hoja 2: Tt= 64MB y Tb= 1KB.
Hay una tabla con una entrada para cada bloque. Esta tendra = Tt/Tb entradas = 2^16 = 64K bloques/entradas.
Laa longitud de cada entrada sera log2 de 2^16 = 16 bits.
Suponemos que el bloue 0 no esta libre o disponible pr dicheros, porque contendra la tabla FAT.
El tamaño total de la tbla seria 16b (2B) de cada entrada * 64K entradas que hay = 128K bytes
-----------------------------------------------------------------------------------------------------------------------------
Ejercicio 11 hoja 2: resuelto en el PDF.
-----------------------------------------------------------------------------------------------------------------------------
//Terminal: Ejercicio 13 hoja 2: 
truncate --size 100M fs.ext2 // Reservar memoria para el inodo.
mkfs.ext2 fs.ext2 // para crear un sistema de ficheros que usa bloques indexados.
mkdir mnt // Creamos un directorio pater el SF.
sudo  mount -t ext2 -o loop ./fs.ext2 ./mnt/ 	// Para montar o desmontar se necesitan permisos de superusuario. Loop para
						// decirle que el SF esta dentro de otro SF.
echo 123456789 > small.txt // Creamos un archivo pequeñito.
dd if=/dev/random of=/big bs=024 count=520 // Un archivo grande. Del tamaño del bloque.
dd if=/dev/random of=/sparse bs=024 count=1 seek=51192 // Un archivo sparse.
// Para ver cosas del FS. No es el mismo stat que hemos usado hasta ahora. X es el numero de inodo que queramos ver. Y
// ponerle el FS que queremos ver.
debugfs -R "stat"<x> ../fs.ext2

// Para ir al bloque 1025 con dd. Pero como no sabemos cuento ocupa la tabla de inodos y demas cosas intermedias no nos
// da lo que queremos ver que deberia ser 123456789.
dd if=./fs.ext2 of=./salida bs=1024 count=1 seek=1025
-----------------------------------------------------------------------------------------------------------------------------
Ejercicio 16 hoja 2: resuelto en el cuadernos 10-10-2025 SO.
-----------------------------------------------------------------------------------------------------------------------------