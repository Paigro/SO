-----------------------------------------------------------------------------------------------------------------------------
TEMA 3: PROCESOS.
-----------------------------------------------------------------------------------------------------------------------------
LEYENDA:
Bloque de terminal o codigo en C: //Terminal:.
Codigo en C: [malloc()].
Comandos en terminal: {ls -a}.
Variables de terminal o de C: 'fd'.
-----------------------------------------------------------------------------------------------------------------------------
Todos los procesos tienen un identificador unico (PID) con [get pid()] y un padre (PPID) con [getppid()].
Con {ps} obtenemos informacion del porceso. Con {-a} se ven todos y con {-aH} los identa por parentesco. Con {aHl} se 
muestra tambien el PPID. UID es el id del propietario del proceso.
Cuando se ejecutan comando en consolas, todos los porcesos que se crean tienen como padre la propia consola. Con el 
propietario usuario efectivo podemos saber los permisos y como se implementan en la practica.
-----------------------------------------------------------------------------------------------------------------------------
Crear procesos: [pid = pid_t fork(void)], crea un proceso clon al que lo crea. Devuelve 0 si es el hijo, el PID del hijo si
es el padre y´-1 si da error. Se clona toda la estructura (memoria virtual (hace un copy on write, no copia todo si no es
necesario, solo cuando se modifica), contexto de ejecucion, tabla de descriptores (se copia el puntero no la estructura como 
tal. Poner 'close_on_exec' para que no se mantenga abierto despues de acabar los forks) y manejadores de señales) y solo
cambian los identificadores y algunas cosas mas.
[pid] contiene el identificador del hijo que ha creado si es el padre, porque no hay funcion para saber los hijos de un
proceso.
[execl/execv]: ejecucion de exec en modo lista o en modo vector. Modo lista por ejemplo ""ls"(exe),"ls"(0),"-a"(1),"-l"(2),
"NULL"". Modo vector, se crea un "char** con ls(0),-a(1),-l(2),NULL(3)"
Luego esta [execXp] entonces busca el ejecutable en el path que le pases y [execXe] para especificarle el entonrno.
-----------------------------------------------------------------------------------------------------------------------------
Terminacion de procesos: puede acabar por manera voluntaria llamando a [_exit(2)] o porque ha llegado al return de main o al
recibir una señal para que termine. Por convenio cuando se llama a [_exit()] se le pasa 0 cuando todo bien y 1 cuando error.
No usar -1 ni numeros raros. Con &? sabemos esto.
Cuando se cierra se cierran los descriptores de fichero. Cuando acaba un proceso hijo se notifica al padre y eso se puede
capturar.
Usaremos [exit()] de la libreria estandar de C que llama a muchas cosas para finalizar el proceso.
Estado Zombie: cuando un proceso termina se devuelve el resultado de la ejecucion y se guarda. El padre tendra que
sincronizar esa finalizacion. Si esta sincronizacion no se hace se queda en estado Zombie.
Dos formas de esperar a que un proceso termine, con [pid_t wait(int)] o [pid_t waitpid(pid_t, int, int)].
-----------------------------------------------------------------------------------------------------------------------------
Problema de que el padre acabe antes que los hijos. Hay un proceso especial (init) que es el primero que se ejecuta, el que
arranca el kernel despues de inicializar el sistema. Hay varios asi: systemd, OpenRC, sysinit, ...
subreaper (recolector): cuando detecta un proceso hijo sin padre lo recolecta y los pone como sus hijos para que no se queden
zombien (creo?). Porque la unica forma de liberar un proceso es con el wait(), al quedarse sin padre no se pueden liberar
por eso existe esto.
-----------------------------------------------------------------------------------------------------------------------------
Con {ps} se ven los procesos activos creo.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 5 hoja 3:
int main(int argc, char* argv[])
{
	pid_t pid;
	pid = fork();

	switch (pid) {
    		case -1: // Es error.
        		perror("fork");
        		exit(1);
    		case 0: // Es hijo.
		        printf("Hijo: %i (padre: %i)\n", getpid(), getppid());
		        break;
		default: // Es padre.
        		printf("Padre: %i (hijo: %i)\n", getpid(), pid);
			sleep(600); // Para ver que pasa si el hijo se queda zombie.
		        break;
    }
	return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 9 hoja 3:
int main(int argc, char* argv[])
{
	pid_t pid;
	int rc;
	pid = fork();

	switch (pid) {
    		case -1: // Es error.
        		perror("fork");
        		exit(1);
    		case 0: // Es hijo.
		        printf("Hijo: %i (padre: %i)\n", getpid(), getppid());

			// Queremos el modo vector porque ya lo tenemos en modo vector y p para que nos busque en el path.
			rc= execvp(argv[1], &argv[1] || argv+1)
			if(rc==-1)
			{
				perror("execvp()");
			}			
			printf("No sale nada"); // Si todo va bien no deberia de escribirse este printf.
		        return(1);
		default: // Es padre.
        		printf("Padre: %i (hijo: %i)\n", getpid(), pid);

			int status;
			rc = waitpid(pid, &status, 0);
			if(rc==-1)
			{
				perrorw("waitpid()");
			}
        		if(WIFEXITED(s))
			{
				printf("Hijo termino con codigo: %i\n", WEXITSTATUS(s));

			}
			else if(WIFSIGNALE(s))
			{
				printf("Hijo termino con señal: %i\n", WTERMSIG(s));
			}
    }
	return 0;
}
// Cuidado con como se llama al codigo, si le pasamos ./9 ls "-l -a" en vez de .9/ ls -l -a, los dos argumentos se pasan
// como solo 1 entonces al llamar al exec daria error porque ningun argumento es "-l -a".
-----------------------------------------------------------------------------------------------------------------------------
SEÑALES: son interrupciones del software, que informan a un proceso de un evento de manera asincrona. Depende de la señal
se pueden hacer unas cosas u otras. Las genera un proceso o el propio nucleo del sistema.
Las señakes se pueden ignorar, dejar pendientes a procesar, manejarlas o que se haga lo que la señal hago por defecto.
Hay algunas señales que no se puede bloquear, capturar o ignorar.
Para mandar una señal se usa [kill(pid_t, int)]. Se llama kill el comando porque es la mas tipica pero se puede mandar
cualquier int (señal).
-----------------------------------------------------------------------------------------------------------------------------
SESIONES Y GRUPOS:
Para hacer una sesion nueva y dado que el proceso que querra hacerlo ya es lider de sesion o de grupo lo que se hace es
hacer un fork y llamar a la creacion de nueva sesion en el hijo, porque no es nadie y "lo ascendemos".
Se crea una sesion con [pid_t setsid(void)].
En una misma shell pueden haber varias sesiones. Con {jobs} se ven, con {fg} y {bg} se mandan al background o al foreground,
tambien con & al ejecutar un comando lo manda al background directamente. Si no se especifica nada al hacer {fg} o {bg} este
actua sobre el proceso que tenga el '+' (se ve al llamar a {jobs}). Tambien hay un '-' que es que cuando desaparezca el que
tiene el '+' es el que se pone el '+'.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 11 y 12 hoja 3: la repsuesta al 12 es no. Si se usa el mismo descriptor de escritura se escribiria  en desorden
//creo.
#define NUM 5

void imprimir_indice(int fd, int indice){
    char buffer[NuM];
    for(int i=0; i<NUM; i++){
        buffer[i] = '0' + indice; // Desplazamiento del puntero
    }

    write(fd, buffer, NUMsizeof(char));

    /
    char buffer[NUM+1];


    /
}

int main(int argc, charargv[]) {
    pid_t pid;
    int rc;

    int fd = open("archivo.txt", 
        O_WRONLY | O_CREATE | O_TRUNC, 
        0660);

    imprimir_indice(fd, 0); // Padre

    close(fd);

    for(int indice = 1; indice <= 6; indice++){
        pid_t pid = fork();

        // Solo el padre crea nuevos procesos
        if (pid != 0) {
            continue;
        }
        // El padre no entra aqui
        // cada hijo tiene su archivo
        fd = open("archivo.txt", O_WRONLY);
        // Como hijo, nos posicionamos en el lugar correcto
        lseek(fd, indice * NUM, SEEK_SET);
        srandom(indice);
        sleep(random() % 3);
        imprimir_indice(fd, indice);

        close(fd);
        return 0;
    }

    // Esperamos a los hijos
    for(int i=0; i<=5; i++){
        int s;
        waitpid(0, &s, 0);
        // Obtener el PID del hijo que ha terminado
        if (WIFEXITED(s)) {
            printf("Hijo [%i]finalizado con codigo %d\n", rc, WEXITSTATUS(s));
        }
    }
    return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
MULTIPROGRAMACION: uso de un proceso de la CPU mientras otro no la esta usando (por ejemplo esta con E-S). Mejora la
eficiencia.
Hay que ver a que proceso se le asigna la CPU (con Algoritmos de Planificacion)(1), como cambiar de un proceso a otro (cambio
de contexto)(2) y cuando evaluamos el estado del sistema (Tick de reloj)(3).
Niveles de planificacion: tres tipos.
-Largo plazo: control de admision de trabajos.
-Medio plazo: mueve los procesos de memoria principal a secundaria.
-Corto plazo: decide los procesos que estan disponibles para ejecutarse a continuacion en la CPU.
El unico planificador en los SO generales son de corto plazo. Los de largo plazo se implementan con aplicaciones especificas
externas que actuan sobre el SO. Los de medio plazo reemplazados por los mecanismos de paginacion. Aunque en algunos casos
el SO de Android usa este metodo para suspender aplicaciones a segundo plano.
(3)ACTIVACION DEL PLANIFICADOR (ticks):
Para determinar cuando se ejecuta el Planificador. Cada x tiempo se manda. No esta bien del todo porque hay veces que no es
necesarioejecutar el Planificador porque no hay nada que hacer (si esto estuviese en moviles la bateria duraria 2/3 veces
menos). Entonces hay un modo que es tickless. Se programan las interrupciones a demanda. Es mejor para moviles. Esto hace
que la CPU puede ponerse en modo Idle, pero es costoso la entrada-salida a ese modo.
Linux usa una combinacion de ambas, tickless cuando solo hay una tarea (asi evita interrumpir periodicamente para llamar al
planificador. Siempre hay un core que no entra en modo Idle por obvias razones que si todos estan idles pues alomejor no se
despierta ninguno.
Hay eventos para la activacion de planificacion. Hay para cuando hay un cambio de estado en un proceso, cuando se crea o
destruye un proceso o por cesion voluntaria (el proceso cambia su prioridad (con nice()) o cede a la CPU)
(2)CAMBIOS DE CONTEXTO:
Para cambiar de un proceso a otro hay que reajustar el contexto: cambiar la Memoria Virtual (actualizacion de los registros
al nuevo contexto) y cambio de contexto de ejecucion de la CPU (hay que guardar los registros generales, contador de
programa, pila, registros especificos; actualizar el puntero de pila a la nueva tarea, cargar los registros del nuevo
proceso y continuar con la ejecucion del nuevo proceso).
Este proceso es costoso. Pero el cambio de contexto entre threads es menor (Memoria Virtual) pero no despreciable.

(1)OBJETIVOS DE PLANIFICACION:
El planificador esun algortimo que asigna recursos a los procesos tratando de optimizar un objetivo.
Hay varios objetivos:
-Utilizacion: maximizar el uso de la CPU.
-Productividad: maximizar el numero de procesos terminados por unidad de tiempo.
-Tiempo de respuesta: minimar el tiempo que empieza el proceso hasta la primera respuesta.
-Turnaround: minimizar el tiempo desde que entra un proceso hasta que termina. Desde fork() hasta exit().
-Tiempo de espera: minimizar el tiempo total en la cola de espera. TE = Turnaround - Tiempo CPU - Tiempo E-S.
-Fairness (justicia): reparto equitativo de los recusoso modulado por prioridad y caracteristicas de cada proceso. Si a un
proceso no le das CPU se llama inanicion, se queda sin comer ñam ñam no y eso mal.
Modelos de planificacion:
-Expropiativo: el proceso usa la CPU hasta que un planificador decide reemplazarlo por otro. Cooperacion.
-No expropiativo: el proceso usa la CPU hasta que termina, entra en espera de evento o la cede voluntariamente. Egoista.
-----------------------------------------------------------------------------------------------------------------------------
Al hacer {ps -e} los procesos que pogan "k%" son los procesos del kernel. % = como en BD.
-----------------------------------------------------------------------------------------------------------------------------







