-----------------------------------------------------------------------------------------------------------------------------
TEMA 3: PROCESOS.
-----------------------------------------------------------------------------------------------------------------------------
LEYENDA:
Bloque de terminal o codigo en C: //Terminal:.
Codigo en C: [malloc()].
Comandos en terminal: {ls -a}.
Variables de terminal o de C: 'fd'.
-----------------------------------------------------------------------------------------------------------------------------
Todos los procesos tienen un identificador unico (PID) con [get pid()] y un padre (PPID) con [getppid()].
Con {ps} obtenemos informacion del porceso. Con {-a} se ven todos y con {-aH} los identa por parentesco. Con {aHl} se 
muestra tambien el PPID. UID es el id del propietario del proceso.
Cuando se ejecutan comando en consolas, todos los porcesos que se crean tienen como padre la propia consola. Con el 
propietario usuario efectivo podemos saber los permisos y como se implementan en la practica.
-----------------------------------------------------------------------------------------------------------------------------
Crear procesos: [pid = pid_t fork(void)], crea un proceso clon al que lo crea. Devuelve 0 si es el hijo, el PID del hijo si
es el padre y´-1 si da error. Se clona toda la estructura (memoria virtual (hace un copy on write, no copia todo si no es
necesario, solo cuando se modifica), contexto de ejecucion, tabla de descriptores (se copia el puntero no la estructura como 
tal. Poner 'close_on_exec' para que no se mantenga abierto despues de acabar los forks) y manejadores de señales) y solo
cambian los identificadores y algunas cosas mas.
[pid] contiene el identificador del hijo que ha creado si es el padre, porque no hay funcion para saber los hijos de un
proceso.
[execl/execv]: ejecucion de exec en modo lista o en modo vector. Modo lista por ejemplo ""ls"(exe),"ls"(0),"-a"(1),"-l"(2),
"NULL"". Modo vector, se crea un "char** con ls(0),-a(1),-l(2),NULL(3)"
Luego esta [execXp] entonces busca el ejecutable en el path que le pases y [execXe] para especificarle el entonrno.
-----------------------------------------------------------------------------------------------------------------------------
Terminacion de procesos: puede acabar por manera voluntaria llamando a [_exit(2)] o porque ha llegado al return de main o al
recibir una señal para que termine. Por convenio cuando se llama a [_exit()] se le pasa 0 cuando todo bien y 1 cuando error.
No usar -1 ni numeros raros. Con &? sabemos esto.
Cuando se cierra se cierran los descriptores de fichero. Cuando acaba un proceso hijo se notifica al padre y eso se puede
capturar.
Usaremos [exit()] de la libreria estandar de C que llama a muchas cosas para finalizar el proceso.
Estado Zombie: cuando un proceso termina se devuelve el resultado de la ejecucion y se guarda. El padre tendra que
sincronizar esa finalizacion. Si esta sincronizacion no se hace se queda en estado Zombie.
Dos formas de esperar a que un proceso termine, con [pid_t wait(int)] o [pid_t waitpid(pid_t, int, int)].
-----------------------------------------------------------------------------------------------------------------------------
Problema de que el padre acabe antes que los hijos. Hay un proceso especial (init) que es el primero que se ejecuta, el que
arranca el kernel despues de inicializar el sistema. Hay varios asi: systemd, OpenRC, sysinit, ...
subreaper (recolector): cuando detecta un proceso hijo sin padre lo recolecta y los pone como sus hijos para que no se queden
zombien (creo?). Porque la unica forma de liberar un proceso es con el wait(), al quedarse sin padre no se pueden liberar
por eso existe esto.
-----------------------------------------------------------------------------------------------------------------------------
Con {ps} se ven los procesos activos creo.
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 5 hoja 3:
int main(int argc, char* argv[])
{
	pid_t pid;
	pid = fork();

	switch (pid) {
    		case -1: // Es error.
        		perror("fork");
        		exit(1);
    		case 0: // Es hijo.
		        printf("Hijo: %i (padre: %i)\n", getpid(), getppid());
		        break;
		default: // Es padre.
        		printf("Padre: %i (hijo: %i)\n", getpid(), pid);
			sleep(600); // Para ver que pasa si el hijo se queda zombie.
		        break;
    }
	return 0;
}
-----------------------------------------------------------------------------------------------------------------------------
//Ejercicio 9 hoja 3:
int main(int argc, char* argv[])
{
	pid_t pid;
	int rc;
	pid = fork();

	switch (pid) {
    		case -1: // Es error.
        		perror("fork");
        		exit(1);
    		case 0: // Es hijo.
		        printf("Hijo: %i (padre: %i)\n", getpid(), getppid());

			// Queremos el modo vector porque ya lo tenemos en modo vector y p para que nos busque en el path.
			rc= execvp(argv[1], &argv[1] || argv+1)
			if(rc==-1)
			{
				perror("execvp()");
			}			
			printf("No sale nada"); // Si todo va bien no deberia de escribirse este printf.
		        return(1);
		default: // Es padre.
        		printf("Padre: %i (hijo: %i)\n", getpid(), pid);

			int status;
			rc = waitpid(pid, &status, 0);
			if(rc==-1)
			{
				perrorw("waitpid()");
			}
        		if(WIFEXITED(s))
			{
				printf("Hijo termino con codigo: %i\n", WEXITSTATUS(s));

			}
			else if(WIFSIGNALE(s))
			{
				printf("Hijo termino con señal: %i\n", WTERMSIG(s));
			}
    }
	return 0;
}
// Cuidado con como se llama al codigo, si le pasamos ./9 ls "-l -a" en vez de .9/ ls -l -a, los dos argumentos se pasan
// como solo 1 entonces al llamar al exec daria error porque ningun argumento es "-l -a".
-----------------------------------------------------------------------------------------------------------------------------
SEÑALES: son interrupciones del software, que informan a un proceso de un evento de manera asincrona. Depende de la señal
se pueden hacer unas cosas u otras. Las genera un proceso o el propio nucleo del sistema.
Las señakes se pueden ignorar, dejar pendientes a procesar, manejarlas o que se haga lo que la señal hago por defecto.
Hay algunas señales que no se puede bloquear, capturar o ignorar.
Para mandar una señal se usa [kill(pid_t, int)]. Se llama kill el comando porque es la mas tipica pero se puede mandar
cualquier int (señal).
-----------------------------------------------------------------------------------------------------------------------------
SESIONES Y GRUPOS:
Para hacer una sesion nueva y dado que el proceso que querra hacerlo ya es lider de sesion o de grupo lo que se hace es
hacer un fork y llamar a la creacion de nueva sesion en el hijo, porque no es nadie y "lo ascendemos".
Se crea una sesion con [pid_t setsid(void)].
En una misma shell pueden haber varias sesiones. Con {jobs} se ven, con {fg} y {bg} se mandan al background o al foreground,
tambien con & al ejecutar un comando lo manda al background directamente. Si no se especifica nada al hacer {fg} o {bg} este
actua sobre el proceso que tenga el '+' (se ve al llamar a {jobs}). Tambien hay un '-' que es que cuando desaparezca el que
tiene el '+' es el que se pone el '+'.






